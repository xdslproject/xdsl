"""
This type stub file was generated by pyright.
"""

from ctypes import Structure
from enum import IntFlag

from llvmlite.binding import ffi

def create_new_module_pass_manager():  # -> ModulePassManager:
    ...
def create_new_function_pass_manager():  # -> FunctionPassManager:
    ...
def create_pass_builder(tm, pto):  # -> PassBuilder:
    ...
def create_pipeline_tuning_options(
    speed_level=..., size_level=...
):  # -> PipelineTuningOptions:
    ...

_prunestats = ...

class PruneStats(_prunestats):
    """Holds statistics from reference count pruning."""
    def __add__(self, other):  # -> PruneStats:
        ...
    def __sub__(self, other):  # -> PruneStats:
        ...

class _c_PruneStats(Structure):
    _fields_ = ...

def dump_refprune_stats(printout=...):  # -> PruneStats:
    """Returns a namedtuple containing the current values for the refop pruning
    statistics. If kwarg `printout` is True the stats are printed to stderr,
    default is False.
    """
    ...

def set_time_passes(enable):  # -> None:
    """Enable or disable the pass timers.

    Parameters
    ----------
    enable : bool
        Set to True to enable the pass timers.
        Set to False to disable the pass timers.
    """
    ...

def report_and_reset_timings():  # -> str:
    """Returns the pass timings report and resets the LLVM internal timers.

    Pass timers are enabled by ``set_time_passes()``. If the timers are not
    enabled, this function will return an empty string.

    Returns
    -------
    res : str
        LLVM generated timing report.
    """
    ...

class RefPruneSubpasses(IntFlag):
    PER_BB = ...
    DIAMOND = ...
    FANOUT = ...
    FANOUT_RAISE = ...
    ALL = ...

class NewPassManager:
    def __init__(self) -> None: ...
    def run(self, IR, pb):  # -> None:
        ...
    def add_aa_eval_pass(self):  # -> None:
        ...
    def add_simplify_cfg_pass(self):  # -> None:
        ...
    def add_loop_unroll_pass(self):  # -> None:
        ...
    def add_instruction_combine_pass(self):  # -> None:
        ...
    def add_jump_threading_pass(self, threshold=...):  # -> None:
        ...
    def add_cfg_printer_pass(self):  # -> None:
        ...
    def add_cfg_only_printer_pass(self):  # -> None:
        ...
    def add_dom_printer_pass(self):  # -> None:
        ...
    def add_dom_only_printer_pass(self):  # -> None:
        ...
    def add_post_dom_printer_pass(self):  # -> None:
        ...
    def add_post_dom_only_printer_pass(self):  # -> None:
        ...
    def add_dom_viewer_pass(self):  # -> None:
        ...
    def add_dom_only_viewer_pass(self):  # -> None:
        ...
    def add_post_dom_viewer_pass(self):  # -> None:
        ...
    def add_post_dom_only_viewer_pass(self):  # -> None:
        ...
    def add_lint_pass(self):  # -> None:
        ...
    def add_aggressive_dce_pass(self):  # -> None:
        ...
    def add_break_critical_edges_pass(self):  # -> None:
        ...
    def add_dead_store_elimination_pass(self):  # -> None:
        ...
    def add_dead_code_elimination_pass(self):  # -> None:
        ...
    def add_aggressive_instcombine_pass(self):  # -> None:
        ...
    def add_lcssa_pass(self):  # -> None:
        ...
    def add_new_gvn_pass(self):  # -> None:
        ...
    def add_loop_simplify_pass(self):  # -> None:
        ...
    def add_loop_unroll_and_jam_pass(self):  # -> None:
        ...
    def add_sccp_pass(self):  # -> None:
        ...
    def add_lower_atomic_pass(self):  # -> None:
        ...
    def add_lower_invoke_pass(self):  # -> None:
        ...
    def add_lower_switch_pass(self):  # -> None:
        ...
    def add_mem_copy_opt_pass(self):  # -> None:
        ...
    def add_unify_function_exit_nodes_pass(self):  # -> None:
        ...
    def add_reassociate_pass(self):  # -> None:
        ...
    def add_register_to_memory_pass(self):  # -> None:
        ...
    def add_sroa_pass(self):  # -> None:
        ...
    def add_sinking_pass(self):  # -> None:
        ...
    def add_tail_call_elimination_pass(self):  # -> None:
        ...
    def add_instruction_namer_pass(self):  # -> None:
        ...
    def add_loop_deletion_pass(self):  # -> None:
        ...
    def add_loop_strength_reduce_pass(self):  # -> None:
        ...
    def add_loop_rotate_pass(self):  # -> None:
        ...

class ModulePassManager(ffi.ObjectRef, NewPassManager):
    def __init__(self, ptr=...) -> None: ...
    def add_verifier(self):  # -> None:
        ...
    def add_constant_merge_pass(self):  # -> None:
        ...
    def add_dead_arg_elimination_pass(self):  # -> None:
        ...
    def add_dot_call_graph_printer_pass(self):  # -> None:
        ...
    def add_module_debug_info_pass(self):  # -> None:
        ...
    def add_always_inliner_pass(self):  # -> None:
        ...
    def add_rpo_function_attrs_pass(self):  # -> None:
        ...
    def add_global_dead_code_eliminate_pass(self):  # -> None:
        ...
    def add_global_opt_pass(self):  # -> None:
        ...
    def add_ipsccp_pass(self):  # -> None:
        ...
    def add_internalize_pass(self):  # -> None:
        ...
    def add_loop_extract_pass(self):  # -> None:
        ...
    def add_merge_functions_pass(self):  # -> None:
        ...
    def add_partial_inliner_pass(self):  # -> None:
        ...
    def add_strip_symbols_pass(self):  # -> None:
        ...
    def add_strip_dead_debug_info_pass(self):  # -> None:
        ...
    def add_strip_dead_prototype_pass(self):  # -> None:
        ...
    def add_strip_debug_declare_pass(self):  # -> None:
        ...
    def add_strip_non_debug_symbols_pass(self):  # -> None:
        ...
    def add_argument_promotion_pass(self):  # -> None:
        ...
    def add_post_order_function_attributes_pass(self):  # -> None:
        ...
    def add_refprune_pass(self, subpasses_flags=..., subgraph_limit=...):  # -> None:
        """Add Numba specific Reference count pruning pass.

        Parameters
        ----------
        subpasses_flags : RefPruneSubpasses
            A bitmask to control the subpasses to be enabled.
        subgraph_limit : int
            Limit the fanout pruners to working on a subgraph no bigger than
            this number of basic-blocks to avoid spending too much time in very
            large graphs. Default is 1000. Subject to change in future
            versions.
        """
        ...

class FunctionPassManager(ffi.ObjectRef, NewPassManager):
    def __init__(self, ptr=...) -> None: ...
    def add_refprune_pass(self, subpasses_flags=..., subgraph_limit=...):  # -> None:
        """Add Numba specific Reference count pruning pass.

        Parameters
        ----------
        subpasses_flags : RefPruneSubpasses
            A bitmask to control the subpasses to be enabled.
        subgraph_limit : int
            Limit the fanout pruners to working on a subgraph no bigger than
            this number of basic-blocks to avoid spending too much time in very
            large graphs. Default is 1000. Subject to change in future
            versions.
        """
        ...

class PipelineTuningOptions(ffi.ObjectRef):
    def __init__(self, speed_level=..., size_level=...) -> None: ...
    @property
    def speed_level(self):  # -> None:
        ...
    @speed_level.setter
    def speed_level(self, value):  # -> None:
        ...
    @property
    def size_level(self):  # -> int | None:
        ...
    @size_level.setter
    def size_level(self, value):  # -> None:
        ...
    @property
    def loop_interleaving(self): ...
    @loop_interleaving.setter
    def loop_interleaving(self, value):  # -> None:
        ...
    @property
    def loop_vectorization(self): ...
    @loop_vectorization.setter
    def loop_vectorization(self, value):  # -> None:
        ...
    @property
    def slp_vectorization(self): ...
    @slp_vectorization.setter
    def slp_vectorization(self, value):  # -> None:
        ...
    @property
    def loop_unrolling(self): ...
    @loop_unrolling.setter
    def loop_unrolling(self, value):  # -> None:
        ...
    @property
    def inlining_threshold(self): ...
    @inlining_threshold.setter
    def inlining_threshold(self, value):  # -> None:
        ...

class TimePassesHandler(ffi.ObjectRef):
    def __init__(self) -> None: ...

class PassBuilder(ffi.ObjectRef):
    def __init__(self, tm, pto) -> None: ...
    def getModulePassManager(self):  # -> ModulePassManager:
        ...
    def getFunctionPassManager(self):  # -> FunctionPassManager:
        ...
    def start_pass_timing(self):  # -> None:
        """Enable the pass timers.

        Raises
        ------
        RuntimeError
            If pass timing is already enabled.
        """
        ...

    def finish_pass_timing(self):  # -> str:
        """Returns the pass timings report and disables the LLVM internal
        timers. Pass timers are enabled by ``start_pass_timing()``. If the
        timers are not enabled, this function will return an empty string.

        Returns
        -------
        res : str
            LLVM generated timing report.
        """
        ...
